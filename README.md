# Частично персистентный связный список с O(1) на операцию. 

Частично персистентный связный список с O(1) на операцию с методами path coping и fat node.

## Общие понятия
Связный список — базовая динамическая структура данных в информатике, состоящая из узлов, 
каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на 
следующий и/или предыдущий узел списка. 

Частично персистентная структура данных - это структуры данных, которые при 
внесении в них каких-то изменений сохраняют все свои предыдущие состояния 
и доступ к этим состояниям. В частично персистентных структурах данных к каждой версии можно 
делать запросы, но изменять можно только последнюю версию структуры данных. 

## Интерфейс структуры данных

###Интерфейс персистентного списка 

Операции делятся на два типа:
* по индексу 
* по указателю

Во всех операциях по индексу сначала выполняется поиск узла по интексу за O(n), и 
далее выполняется операция. В операциях по указателю поиск выполнять не нужно, 
следовательно, амортизационная стоимость - O(1).  

```
Iterator add(IteratorI it, int value); 
IteratorI edit(IteratorI it, int value);
IteratorI remove(IteratorI it); 
IteratorI getHead(int version);
IteratorI getTail(int version);
IteratorI get(int index); 
IteratorI get(int index, int version);
void add(int index, int value);
void edit(int index, int newValue);
void remove(int index); 
boolean isEmpty();
int getCurrentVersion();
```
См. документацию для деталей.

###Интерфейс итератора

По итератору можно получить текущее значение.
Итератор можно сдвинуть вперед, назад. 

```
boolean hasNext();
boolean hasPrev();
void next();
void prev();
int getValue();
```
См. документацию для деталей.

##Описание структуры данных

Есть два вида вершин: 
* Fat nodes (Большие вершины)
* Nodes (Подвершины)

Большие вершины содержат:
* одну или две подвершины

Подвершины содержат: 
* значение
* номер версии, на которой была создана подвершина
* ссылку на следующую большую вершину
* ссылку на предыдущую большую вершину

Если следующего/предыдущего элемента нет, то ссылка = null.

Есть массив голов(heads) и хвостов(tails), который представляет из себя список 
больших вершин. Чтобы получить головную вершину в списке версии v, надо обратиться к элементу v
в массиве - heads[v], аналогично для получения хвоста - tails[v]. После получения большой 
вершины выбирается подвершина по номеру версии.

Выбор обычной вершины из большой по версии v:
* Если большая вершина имеет одну подвершину - выбираем эту подвершину.
* Если несколько, то выбираем вершину, версия создания которой меньше или равна v.   

## Описание операций 

Для начала введем понятие связки подвершины(subnode) в большой вершине(node) с правой
большой вершиной(rightFatNode). Для левой все делает аналогично. 
* Если rightFatNode имеет одну подвершину, то создаем вторую подвершину в rightFatNode
и ссылка на предыдущую будет указывать на node, а следующая у subnode будет указывать 
на rightFatNode.
* Если rightFatNode имеет две подвершины, то создаем новую большую правую вершину
(newRightFatNode), где будет одна подвершина, у которой ссылка на предыдущюю будет 
указывать на node. Далее запустим этот процесс сначала для newRightFatNode. 

### Добавление
Для добавления нового значения value в список надо:
1. Создать новую большую вершину
2. Добавить в нее одну подвершину со значением value
3. Делее надо связать ссылками текущуюю подвершину в парую и левую стороны.  
 
### Изменение
* Если текущая большая вершина имеет одну подвершину, то надо добавить вторую 
подвершину с новым значением и связать в правую и левую стороны. 
* Если текущая большая вершина имеет одну подвершины, то надо добавить большую вершину
с одной подвершиной и запустить связку в правую и левую стороны. 

### Удаление
Надо добавить по одной новой подвершине(или создать одну новую большую вершину 
с подвершиной) в правого и левого соседа вершины, 
которую надо удалить, и связать в правую и левую стороны новые подвершины 
правого и левого соседа.  

## Тесты
Для проверки был написан наивный алгоритм частично персистентного списка, который 
работает на массиве массивов. Там операция добавления, удаления выполняется за O(n) 
по времени и O(n) по памяти. Операция изменения - О(1) по времени и O(n) по памяти.

Тесты основаны на случайном виде операции и в случайное место списка.

## Сборка
* [Maven](https://maven.apache.org/) - Dependency Management

## Запуск тестов
Тесты можно запустить используя maven.
```
maven test
```

## Автор
* **Маргарита Маркина**(ИТМО, M4239) - [Margarita Markina](https://github.com/markina) 
